---
- name: Validación y Parcheo de Servidor Windows (Excel o ZIP fallback)
  hosts: all
  gather_facts: no
  tasks:

    - name: Obtener ruta del escritorio
      win_shell: |
        [Environment]::GetFolderPath("Desktop")
      register: desktop_path_raw

    - name: Limpiar ruta del escritorio
      set_fact:
        desktop_path: "{{ desktop_path_raw.stdout | trim }}"

    - name: Crear carpeta LogsAnsible en el escritorio si no existe
      win_file:
        path: "{{ desktop_path }}\\LogsAnsible"
        state: directory

    # --- Información general del sistema ---
    - name: Obtener versión de Windows y RAM
      win_shell: |
        $os = Get-CimInstance Win32_OperatingSystem
        [pscustomobject]@{
          WindowsVersion = $os.Caption
          BuildNumber    = $os.BuildNumber
          RAM_GB         = [math]::Round($os.TotalVisibleMemorySize/1MB,2)
        } | ConvertTo-Json -Depth 3
      register: system_info

    - name: Top 5 procesos con más uso de CPU
      win_shell: |
        Get-Process | Sort-Object CPU -Descending |
        Select-Object -First 5 Name, CPU |
        ConvertTo-Json -Depth 3
      register: top_cpu

    - name: Últimos 5 eventos del log de sistema
      win_shell: |
        Get-EventLog -LogName System -Newest 5 |
        Select-Object TimeGenerated, EntryType, Source, EventID, Message |
        ConvertTo-Json -Depth 3
      register: last_events

    # --- Verificación de servicios ---
    - name: Verificar servicios detenidos o fallando
      win_shell: |
        Get-Service | Where-Object { $_.Status -ne 'Running' } |
        Select-Object Name, DisplayName, Status, StartType |
        ConvertTo-Json -Depth 3
      register: service_info

    # --- Revisión de espacio en disco ---
    - name: Verificar espacio en disco
      win_shell: |
        Get-PSDrive -PSProvider FileSystem |
        Select-Object Name,Free,Used, @{Name="TotalGB";Expression={[math]::round($_.Used/1GB + $_.Free/1GB, 2)}} |
        ConvertTo-Json
      register: disk_info

    # --- Instalación de actualizaciones ---
    - name: Instalar todas las actualizaciones disponibles
      win_updates:
        category_names:
          - SecurityUpdates
          - CriticalUpdates
          - UpdateRollups
        reboot: yes
      register: updates_installed

    # --- Historial de parches instalados ---
    - name: Obtener historial de parches instalados
      win_shell: |
        Get-HotFix | Select-Object Description, HotFixID, InstalledOn |
        Sort-Object InstalledOn -Descending |
        ConvertTo-Json -Depth 3
      register: updates_history

    # --- Log legible en TXT ---
    - name: Crear log de validación y parcheo en texto plano
      win_copy:
        content: |
          ==== Validación y Parcheo de Servidor Windows ====

          Información del sistema:
          {{ system_info.stdout }}

          Top 5 procesos con mayor uso de CPU:
          {{ top_cpu.stdout }}

          Últimos 5 eventos del log de sistema:
          {{ last_events.stdout }}

          Servicios detenidos o fallando:
          {{ service_info.stdout }}

          Espacio en disco:
          {{ disk_info.stdout }}

          Actualizaciones instaladas en esta ejecución:
          {% if (updates_installed.updates | default([]) | length) > 0 %}
          {{ updates_installed.updates | to_nice_json }}
          {% else %}
          Sin actualizaciones pendientes
          {% endif %}

          Historial de parches instalados:
          {{ updates_history.stdout }}
        dest: "{{ desktop_path }}\\LogsAnsible\\validacion_y_parcheo_windows.txt"

    # ====== EXCEL ÚNICO (si ImportExcel está disponible) O ZIP DE CSV (fallback) ======

    - name: Comprobar si el módulo ImportExcel está instalado
      win_shell: |
        if (Get-Module -ListAvailable -Name ImportExcel) { 'FOUND' } else { 'MISSING' }
      register: importexcel_status

    - name: Generar Excel único con ImportExcel
      win_shell: |
        $xlsx = "{{ desktop_path }}\LogsAnsible\Reporte_Validacion_Parcheo.xlsx"
        Import-Module ImportExcel -Force

        $services = @'
        {{ service_info.stdout }}
        '@ | ConvertFrom-Json

        $disk = @'
        {{ disk_info.stdout }}
        '@ | ConvertFrom-Json

        $topcpu = @'
        {{ top_cpu.stdout }}
        '@ | ConvertFrom-Json

        $events = @'
        {{ last_events.stdout }}
        '@ | ConvertFrom-Json

        $history = @'
        {{ updates_history.stdout }}
        '@ | ConvertFrom-Json

        $installed = @'
        {{ (updates_installed.updates | default([]) | to_nice_json) }}
        '@ | ConvertFrom-Json
        if ($null -eq $installed) { $installed = @() }

        $services | Export-Excel -Path $xlsx -WorksheetName 'Servicios_NoRunning' -AutoSize -TableName 'Servicios' -ClearSheet
        $disk     | Export-Excel -Path $xlsx -WorksheetName 'Espacio_Disco'     -AutoSize -TableName 'Discos'   -Append
        $topcpu   | Export-Excel -Path $xlsx -WorksheetName 'TopCPU'            -AutoSize -TableName 'TopCPU'   -Append
        $events   | Export-Excel -Path $xlsx -WorksheetName 'Eventos_Sistema'   -AutoSize -TableName 'Eventos'  -Append
        $history  | Export-Excel -Path $xlsx -WorksheetName 'Historial_Parcheo' -AutoSize -TableName 'Historial'-Append
        $installed| Export-Excel -Path $xlsx -WorksheetName 'Updates_Ejecucion' -AutoSize -TableName 'UpdatesRun'-Append
      when: "'FOUND' in importexcel_status.stdout"

    - name: Exportar CSVs y empaquetar en ZIP (fallback sin ImportExcel)
      win_shell: |
        $base = "{{ desktop_path }}\LogsAnsible"
        $svc = Join-Path $base 'Servicios_NoRunning.csv'
        $dsk = Join-Path $base 'Espacio_Disco.csv'
        $cpu = Join-Path $base 'TopCPU.csv'
        $evt = Join-Path $base 'Eventos_Sistema.csv'
        $hst = Join-Path $base 'Historial_Parcheo.csv'
        $upd = Join-Path $base 'Updates_Instalados_Ejecucion.csv'
        $zip = Join-Path $base 'Reporte_Validacion_Parcheo.zip'

        Get-Service | Where-Object { $_.Status -ne 'Running' } |
          Select-Object Name, DisplayName, Status, StartType |
          Export-Csv -Path $svc -NoTypeInformation -Encoding UTF8

        Get-PSDrive -PSProvider FileSystem |
          Select-Object Name,
            @{N="Free_GB";E={[math]::Round($_.Free/1GB,2)}},
            @{N="Used_GB";E={[math]::Round($_.Used/1GB,2)}},
            @{N="Total_GB";E={[math]::Round(($_.Used/1GB + $_.Free/1GB),2)}} |
          Export-Csv -Path $dsk -NoTypeInformation -Encoding UTF8

        Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 Name, CPU |
          Export-Csv -Path $cpu -NoTypeInformation -Encoding UTF8

        Get-EventLog -LogName System -Newest 50 |
          Select-Object TimeGenerated, EntryType, Source, EventID, Message |
          Export-Csv -Path $evt -NoTypeInformation -Encoding UTF8

        Get-HotFix | Select-Object Description, HotFixID, InstalledOn |
          Sort-Object InstalledOn -Descending |
          Export-Csv -Path $hst -NoTypeInformation -Encoding UTF8

        $json = @'
        {{ (updates_installed.updates | default([]) | to_nice_json) }}
        '@
        $obj = $json | ConvertFrom-Json
        if ($null -eq $obj) { $obj = @() }
        $arr = foreach ($u in $obj) {
          [pscustomobject]@{
            Title    = $u.title
            KB       = ($u.kb | Out-String).Trim()
            Category = ($u.categories -join ',')
          }
        }
        $arr | Export-Csv -Path $upd -NoTypeInformation -Encoding UTF8

        if (Test-Path $zip) { Remove-Item $zip -Force }
        Compress-Archive -Path $svc,$dsk,$cpu,$evt,$hst,$upd -DestinationPath $zip -Force
      when: "'MISSING' in importexcel_status.stdout"
