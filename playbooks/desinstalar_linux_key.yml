---
- name: Desinstalar Zabbix en Linux (LLAVE desde Encuesta, multi-OS + debug conexión + limpieza reforzada)
  hosts: a_desinstalar_zabbix_linux
  gather_facts: false
  become: true

  vars:
    # Variables de Encuesta
    usuario_ssh: "{{ usuario_ssh }}"
    puerto_ssh: "{{ puerto_ssh | default(22) }}"
    llave_ssh: "{{ llave_ssh }}"

    # Llave temporal única en el Controller
    private_key_path: "/tmp/aap_key_{{ awx_job_id | default(ansible_date_time.epoch) }}.pem"

    # Parámetros de conexión
    ansible_user: "{{ usuario_ssh }}"
    ansible_port: "{{ puerto_ssh }}"
    ansible_ssh_private_key_file: "{{ private_key_path }}"
    ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

  pre_tasks:
    - name: Validar que 'llave_ssh' esté definida y no vacía
      ansible.builtin.assert:
        that:
          - llave_ssh is defined
          - (llave_ssh | length) > 10
        fail_msg: "Variable 'llave_ssh' vacía o no definida. Revisa la Encuesta."

    - name: Escribir llave privada temporal en el nodo controlador
      ansible.builtin.copy:
        content: "{{ (llave_ssh | replace('\\r','') | replace('\\n','\n')) }}"
        dest: "{{ private_key_path }}"
        mode: '0600'
      run_once: true
      delegate_to: localhost
      vars: { ansible_python_interpreter: /usr/bin/python3 }
      # no_log: true   # actívalo al terminar de depurar

    - name: DEBUG destino (host/puerto)
      ansible.builtin.debug:
        msg: "Voy a conectar a {{ ansible_user }}@{{ hostvars[inventory_hostname].ansible_host | default(inventory_hostname) }}:{{ ansible_port | default(puerto_ssh) }}"

    - name: Probar apertura de puerto con netcat (si existe)
      ansible.builtin.command: >
        sh -lc 'command -v nc >/dev/null 2>&1 &&
        nc -vz {{ hostvars[inventory_hostname].ansible_host | default(inventory_hostname) }}
               {{ ansible_port | default(puerto_ssh) }} || true'
      delegate_to: localhost
      register: nc_test
      changed_when: false
      failed_when: false
      vars: { ansible_python_interpreter: /usr/bin/python3 }

    - name: Resultado netcat
      ansible.builtin.debug:
        var: nc_test.stderr

    - name: Probar apertura de puerto con /dev/tcp (fallback)
      ansible.builtin.shell: >
        timeout 5 bash -lc 'echo >/dev/tcp/{{ hostvars[inventory_hostname].ansible_host | default(inventory_hostname) }}/{{ ansible_port | default(puerto_ssh) }}'
      delegate_to: localhost
      register: devtcp_test
      changed_when: false
      failed_when: false
      vars: { ansible_python_interpreter: /usr/bin/python3 }

    - name: Resultado /dev/tcp (fallback)
      ansible.builtin.debug:
        msg: "{{ 'OK' if devtcp_test.rc == 0 else 'FAIL' }}"

    - name: Esperar que el puerto SSH esté abierto
      ansible.builtin.wait_for:
        host: "{{ hostvars[inventory_hostname].ansible_host | default(inventory_hostname) }}"
        port: "{{ ansible_port | default(puerto_ssh) | int }}"
        timeout: 45
        connect_timeout: 5
        state: started
      delegate_to: localhost
      vars: { ansible_python_interpreter: /usr/bin/python3 }

  tasks:
    - name: Recolectar facts ahora que la conexión está configurada
      ansible.builtin.setup:

    # === Debian / Ubuntu ===
    - name: Detener servicios Zabbix (Debian/Ubuntu)
      ansible.builtin.service:
        name: "{{ item }}"
        state: stopped
      loop: [ 'zabbix-agent', 'zabbix-agent2' ]
      ignore_errors: true
      when: ansible_os_family == "Debian"

    - name: Desinstalar Zabbix (Debian/Ubuntu)
      ansible.builtin.apt:
        name: [ 'zabbix-agent', 'zabbix-agent2' ]
        state: absent
        purge: true
        update_cache: true
      when: ansible_os_family == "Debian"

    # === RedHat / CentOS ===
    - name: Detener servicios Zabbix (RedHat/CentOS)
      ansible.builtin.service:
        name: "{{ item }}"
        state: stopped
      loop: [ 'zabbix-agent', 'zabbix-agent2' ]
      ignore_errors: true
      when: ansible_os_family == "RedHat"

    - name: Desinstalar Zabbix (RedHat/CentOS)
      ansible.builtin.yum:
        name: [ 'zabbix-agent', 'zabbix-agent2' ]
        state: absent
      when: ansible_os_family == "RedHat"

    # === SUSE ===
    - name: Detener servicios Zabbix (SUSE)
      ansible.builtin.service:
        name: "{{ item }}"
        state: stopped
      loop: [ 'zabbix-agent', 'zabbix-agent2' ]
      ignore_errors: true
      when: ansible_os_family == "Suse"

    - name: Desinstalar Zabbix (SUSE)
      community.general.zypper:
        name: [ 'zabbix-agent', 'zabbix-agent2' ]
        state: absent
      when: ansible_os_family == "Suse"

    # ==== Limpieza común de restos ====
    - name: Eliminar archivos y directorios de Zabbix
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /etc/zabbix
        - /var/log/zabbix
        - /var/lib/zabbix
      ignore_errors: true

    # ==== Limpieza reforzada ====
    - name: Detener/Deshabilitar/Enmascarar servicios Zabbix (systemd)
      ansible.builtin.shell: |
        set -euo pipefail
        mapfile -t UNITS < <(systemctl list-unit-files 'zabbix*' --type=service --no-legend | awk '{print $1}')
        for u in "${UNITS[@]}"; do
          [ -n "$u" ] || continue
          systemctl stop "$u" || true
          systemctl disable "$u" || true
          systemctl mask "$u" || true
        done
      args: { executable: /bin/bash }
      ignore_errors: true

    - name: Matar procesos Zabbix y borrar ejecutables reales
      ansible.builtin.shell: |
        set -euo pipefail
        PIDS=$(pgrep -f -a 'zabbix(_|-)?(agent|agent2|proxy)' || true)
        if [ -n "$PIDS" ]; then
          echo "$PIDS" 1>&2 || true
          for pid in $(echo "$PIDS" | awk '{print $1}'); do
            EXE=$(readlink -f "/proc/$pid/exe" || true)
            kill -9 "$pid" 2>/dev/null || true
            [ -n "$EXE" ] && [ -e "$EXE" ] && rm -f "$EXE" || true
          done
        fi
      args: { executable: /bin/bash }
      changed_when: true
      ignore_errors: true

    - name: Eliminar unit files zabbix* y recargar systemd
      ansible.builtin.shell: |
        set -euo pipefail
        rm -f /etc/systemd/system/zabbix* /usr/lib/systemd/system/zabbix* /lib/systemd/system/zabbix* 2>/dev/null || true
        systemctl daemon-reload || true
      args: { executable: /bin/bash }
      ignore_errors: true

    - name: Eliminar entradas de cron relacionadas con Zabbix
      ansible.builtin.shell: |
        set -euo pipefail
        if crontab -u root -l >/tmp/cron.root 2>/dev/null; then
          sed -i '/zabbix/Id' /tmp/cron.root || true
          crontab -u root /tmp/cron.root || true
          rm -f /tmp/cron.root || true
        fi
        grep -Ilr --exclude-dir={.git,proc,sys} -e 'zabbix' /etc/cron* 2>/dev/null | xargs -r sed -i '/zabbix/Id'
      args: { executable: /bin/bash }
      ignore_errors: true

    - name: Buscar y eliminar binarios 'zabbix_agentd' en todo el sistema
      ansible.builtin.shell: |
        set -euo pipefail
        find / -xdev -type f -name 'zabbix_agentd' -exec rm -f {} \; 2>/dev/null || true
      args: { executable: /bin/bash }
      ignore_errors: true

    # ==== Verificación final robusta ====
    - name: Verificación post-desinstalación (sin procesos/binarios ni units)
      ansible.builtin.shell: |
        set -euo pipefail
        pgrep -f 'zabbix(_|-)?(agent|agent2|proxy)' >/dev/null 2>&1 && { echo "AÚN QUEDA ZABBIX (proceso)"; exit 1; }
        command -v zabbix_agentd >/dev/null 2>&1 && { echo "AÚN QUEDA ZABBIX (binario en PATH)"; exit 1; }
        systemctl list-unit-files 'zabbix*' --type=service --no-legend | grep -q . && { echo "AÚN QUEDA ZABBIX (unit files)"; exit 1; }
        [ -e /usr/sbin/zabbix_agentd ] || [ -e /usr/local/sbin/zabbix_agentd ] || [ -e /usr/bin/zabbix_agentd ] && { echo "AÚN QUEDA ZABBIX (ruta típica)"; exit 1; }
        echo "OK: Zabbix no presente"
      args: { executable: /bin/bash }
      register: postcheck
      changed_when: false

  post_tasks:
    - name: Borrar llave temporal del controlador
      ansible.builtin.file:
        path: "{{ private_key_path }}"
        state: absent
      run_once: true
      delegate_to: localhost
