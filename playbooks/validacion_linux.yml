- name: Validacion de servidor Linux
  hosts: linux
  gather_facts: yes
  become: yes

  vars:
    log_path: /var/log/ansible/validacion_linux.log
    services_to_check:
      - sshd
      - cron
      - rsyslog

  pre_tasks:
    - name: Asegurar carpeta del log
      file:
        path: "{{ log_path | dirname }}"
        state: directory
        mode: "0755"

    - name: Encabezado del log
      copy:
        dest: "{{ log_path }}"
        mode: "0644"
        content: |
          === Validacion Linux ===
          Host: {{ inventory_hostname }} ({{ ansible_hostname }})
          Fecha: {{ ansible_date_time.iso8601 }}
          SO: {{ ansible_distribution }} {{ ansible_distribution_version }} (Kernel {{ ansible_kernel }})

          [Estado]

    - name: Uptime legible
      shell: uptime
      register: uptime_out
      changed_when: false

    - name: ultimo arranque
      shell: who -b | awk '{print $3,$4}'
      register: last_boot
      changed_when: false

    - name: Carga promedio
      shell: awk '{print $1,$2,$3}' /proc/loadavg
      register: load_avg
      changed_when: false

    - name: CPU vCPUs
      set_fact:
        vcpus_count: "{{ ansible_processor_vcpus | default(ansible_processor_count) | default('N/A') }}"
      changed_when: false

    - name: Memoria total (GiB)
      set_fact:
        mem_total_gib: "{{ (ansible_memtotal_mb | float / 1024) | round(1) }} GiB"
      changed_when: false

    - name: Escribir estado base al log
      lineinfile:
        path: "{{ log_path }}"
        line: |
          Uptime: {{ uptime_out.stdout }}
          ltimo arranque: {{ last_boot.stdout | default('N/D') }}
          Carga 1/5/15: {{ load_avg.stdout }}
          CPU (vCPUs): {{ vcpus_count }}
          Memoria total: {{ mem_total_gib }}
        create: yes

    - name: Memoria (free -h)
      shell: free -h
      register: free_out
      changed_when: false

    - name: Discos (df -h)
      shell: df -h
      register: df_out
      changed_when: false

    - name: Estado de servicios (systemd)
      shell: "systemctl is-active {{ item }}"
      register: svc_states
      changed_when: false
      failed_when: false
      loop: "{{ services_to_check }}"

    - name: Escribir bloque Memoria/Discos/Servicios
      blockinfile:
        path: "{{ log_path }}"
        marker: ""
        block: |
          [Memoria]
          {{ free_out.stdout }}

          [Discos]
          {{ df_out.stdout }}

          [Servicios]
          {% for r in svc_states.results %}
          - {{ r.item }}: {{ 'OK' if r.stdout == 'active' else r.stdout | upper }}
          {% endfor %}

  tasks:
    #######################################################################
    # PARCHEO POR DISTRIBUCION + CAPTURA DE DETALLE DE PAQUETES
    #######################################################################

    # --- SLES / openSUSE ---
    - name: SLES | Actualizar todo con zypper
      shell: |
        set -o pipefail
        zypper refresh && zypper update -y
      args:
        executable: /bin/bash
      register: zypper_out
      changed_when: "'Nothing to do.' not in zypper_out.stdout"
      failed_when: false
      when: ansible_facts['os_family'] == 'Suse'

    - name: SLES | Guardar detalle de zypper en el log
      blockinfile:
        path: "{{ log_path }}"
        marker: ""
        block: |
          [Parcheo - SLES/zypper]
          {{ (zypper_out.stdout | default('')) | trim }}
          {{ ('\nSTDERR:\n' ~ zypper_out.stderr) if (zypper_out.stderr | default('')) else '' }}
      when: ansible_facts['os_family'] == 'Suse'

    # --- Debian/Ubuntu ---
    - name: Debian/Ubuntu | Update cache
      apt:
        update_cache: yes
      register: apt_cache
      when: ansible_facts['os_family'] == 'Debian'

    - name: Debian/Ubuntu | Dist-upgrade + autoremove
      apt:
        upgrade: dist
        autoremove: yes
      register: apt_upgrade
      when: ansible_facts['os_family'] == 'Debian'

    - name: Debian/Ubuntu | Capturar history de APT (ultimas entradas)
      shell: |
        set -o pipefail
        grep -A3 '^Start-Date:' /var/log/apt/history.log | tail -n 200
      args:
        executable: /bin/bash
      register: apt_hist
      changed_when: false
      failed_when: false
      when: ansible_facts['os_family'] == 'Debian'

    - name: Debian/Ubuntu | Guardar detalle en el log
      blockinfile:
        path: "{{ log_path }}"
        marker: ""
        block: |
          [Parcheo - Debian/Ubuntu]
          Cambios: {{ 'Si' if apt_upgrade.changed else 'No' }}
          {{ apt_hist.stdout | default('Sin entradas relevantes en /var/log/apt/history.log') }}
      when: ansible_facts['os_family'] == 'Debian'

    # --- RedHat / CentOS / Rocky / Alma ---
    - name: RedHat-like | Actualizar todo (ultimas versiones)
      yum:
        name: "*"
        state: latest
      register: yum_upd
      when: ansible_facts['os_family'] == 'RedHat'

    - name: RedHat-like | Capturar historial (paquetes alterados)
      shell: |
        set -o pipefail
        (command -v dnf >/dev/null 2>&1 && dnf -y history info last) || yum -y history info last
      args:
        executable: /bin/bash
      register: yum_hist
      changed_when: false
      failed_when: false
      when: ansible_facts['os_family'] == 'RedHat'

    - name: RedHat-like | Guardar detalle en el log
      blockinfile:
        path: "{{ log_path }}"
        marker: ""
        block: |
          [Parcheo - RedHat-like]
          Cambios: {{ 'Si' if yum_upd.changed else 'No' }}
          {{ yum_hist.stdout | default('Sin historial disponible (yum/dnf history)') }}
      when: ansible_facts['os_family'] == 'RedHat'

    #######################################################################
    # RESUMEN & REINICIO CONDICIONAL
    #######################################################################
    - name: Marcar resumen de parchado
      blockinfile:
        path: "{{ log_path }}"
        marker: ""
        block: |
          [Resumen de parchado]
          Distribucion: {{ ansible_distribution }} {{ ansible_distribution_version }}
          Kernel: {{ ansible_kernel }}
          Resultado:
          {% if ansible_facts['os_family'] == 'Debian' %}
          - Cambios aplicados: {{ 'Si' if apt_upgrade.changed else 'No' }}
          {% elif ansible_facts['os_family'] == 'Suse' %}
          - Cambios aplicados: {{ 'Si' if (zypper_out.stdout is defined and 'Nothing to do.' not in zypper_out.stdout) else 'No' }}
          {% elif ansible_facts['os_family'] == 'RedHat' %}
          - Cambios aplicados: {{ 'Si' if yum_upd.changed else 'No' }}
          {% else %}
          - Cambios aplicados: Indefinido
          {% endif %}

    # Senales de "reboot requerido" por distro
    - name: Debian/Ubuntu | Reinicio requerido?
      stat:
        path: /var/run/reboot-required
      register: reboot_req_deb
      when: ansible_facts['os_family'] == 'Debian'

    - name: Suse/RedHat | Reinicio requerido? (needs-restarting -r)
      shell: |
        set -o pipefail
        if command -v needs-restarting >/dev/null 2>&1; then
          needs-restarting -r
        else
          # Si no existe la utilidad, asumimos no requerido (rc=0)
          exit 0
        fi
      args:
        executable: /bin/bash
      register: needs_restarting_cmd
      changed_when: false
      failed_when: false
      when: ansible_facts['os_family'] in ['Suse','RedHat']

    - name: Determinar flag de reinicio
      set_fact:
        reboot_needed: >-
          {{
            (reboot_req_deb.stat.exists | default(false))
            or
            (needs_restarting_cmd.rc is defined and needs_restarting_cmd.rc == 1)
          }}

    - name: Escribir estado de reinicio en log
      lineinfile:
        path: "{{ log_path }}"
        line: "[Reinicio] Requerido: {{ 'Si' if reboot_needed else 'No' }}"
        create: yes

    - name: Reiniciar si es necesario
      reboot:
        msg: "Reinicio automatizado por actualizacion de sistema"
        connect_timeout: 5
        reboot_timeout: 1800
        pre_reboot_delay: 0
        post_reboot_delay: 30
        test_command: "whoami"
      when: reboot_needed

    - name: Post-reboot | Escribir kernel activo
      shell: uname -r
      register: kernel_after
      changed_when: false

    - name: Post-reboot | Registrar kernel en log
      lineinfile:
        path: "{{ log_path }}"
        line: "[Post-reboot] Kernel activo: {{ kernel_after.stdout }}"
        create: yes
